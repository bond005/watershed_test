#ifndef IMAGE_PROCESSING_LIB_H
#define IMAGE_PROCESSING_LIB_H

#include <QVector>

class TPoint2D{
public:
    int x, y;
    TPoint2D() { x = 0; y = 0; }
    TPoint2D(int newX, int newY) { x = newX; y = newY; }
};
typedef QVector<TPoint2D> TClusterOfImage;

/* Выполнить фильтрацию растрового изображения, заданного развёрнутой по
строкам матрицей яркостей пикселей aPixelsOfImage[] шириной nImageWidth и
высотой nImageHeight. Маска фильтра задана матрицей коэффициентов aFilterMask[]
размером nMaskWidth на nMaskHeight пикселей, также развёрнутой по строкам.
   В процессе работы функции используется вспомогательная матрица яркостей
пикселей, имеющая такие же размеры, как и исходная матрица яркостей пикселей
aPixelsOfImage[]. Вспомогательная матрица нужна для временного хранения новых
значений яркостей пикселей, полученных после применения маски фильтра к
соответствующим пикселям исходной матрицы. Память для вспомогательной матрицы
выделяется и удаляется автоматически. */
void filter_image(float aPixelsOfImage[], int nImageWidth, int nImageHeight,
                  const float aFilterMask[], int nMaskWidth, int nMaskHeight);

/* Выполнить фильтрацию растрового изображения, заданного развёрнутой по
строкам матрицей яркостей пикселей aPixelsOfImage[] шириной nImageWidth и
высотой nImageHeight. Маска фильтра задана матрицей коэффициентов aFilterMask[]
размером nMaskWidth на nMaskHeight пикселей, также развёрнутой по строкам.
   В процессе работы функции используется вспомогательная матрица яркостей
пикселей, имеющая такие же размеры, как и исходная матрица яркостей пикселей
aPixelsOfImage[]. Вспомогательная матрица нужна для временного хранения новых
значений яркостей пикселей, полученных после применения маски фильтра к
соответствующим пикселям исходной матрицы. Память для вспомогательной матрицы
должна быть выделена пользователем ещё до вызова самой функции filter_image.
Указатель на эту память передаётся в качестве аргумента aTmpPixelsOfImage[]. */
void filter_image(float aPixelsOfImage[], int nImageWidth, int nImageHeight,
                  const float aFilterMask[], int nMaskWidth, int nMaskHeight,
                  float aTmpPixelsOfImage[]);

/* Сгладить растровое изображение, заданное развёрнутой по строкам матрицей
яркостей пикселей aPixelsOfImage[] шириной nImageWidth и высотой nImageHeight,
с помощью однородного усредняющего фильтра, имеющего маску размером nMaskWidth
на nMaskHeight пикселей, либо с помощью медианного фильтра с маской такого же
размера. Аргумент bIsMedian определяет тип фильтра, используемого для
сглаживания (true - медианный, false - однородный усредняющий).
   В процессе работы функции используется вспомогательная матрица яркостей
пикселей, имеющая такие же размеры, как и исходная матрица яркостей пикселей
aPixelsOfImage[]. Вспомогательная матрица нужна для временного хранения новых
значений яркостей пикселей, полученных после применения маски фильтра к
соответствующим пикселям исходной матрицы. Память для вспомогательной матрицы
выделяется и удаляется автоматически. */
void smooth_image(float aPixelsOfImage[], int nImageWidth, int nImageHeight,
                  int nMaskWidth, int nMaskHeight, bool bIsMedian);

/* Сгладить растровое изображение, заданное развёрнутой по строкам матрицей
яркостей пикселей aPixelsOfImage[] шириной nImageWidth и высотой nImageHeight,
с помощью однородного усредняющего фильтра, имеющего маску размером nMaskWidth
на nMaskHeight пикселей, либо с помощью медианного фильтра с маской такого же
размера. Аргумент bIsMedian определяет тип фильтра, используемого для
сглаживания (true - медианный, false - однородный усредняющий).
   В процессе работы функции используется вспомогательная матрица яркостей
пикселей, имеющая такие же размеры, как и исходная матрица яркостей пикселей
aPixelsOfImage[]. Вспомогательная матрица нужна для временного хранения новых
значений яркостей пикселей, полученных после применения маски фильтра к
соответствующим пикселям исходной матрицы. Память для вспомогательной матрицы
должна быть выделена пользователем ещё до вызова самой функции filter_image.
Указатель на эту память передаётся в качестве аргумента aTmpPixelsOfImage[]. */
void smooth_image(float aPixelsOfImage[], int nImageWidth, int nImageHeight,
                  int nMaskWidth, int nMaskHeight, bool bIsMedian,
                  float aTmpPixelsOfImage[]);

/* Вычислить градиент яркости растрового изображения, заданного развёрнутой по
строкам матрицей яркостей пикселей aPixelsOfImage[] шириной nImageWidth и
высотой nImageHeight. Вычисленный градиент изображения записать в
aPixelsOfImage[] вместо исходного изображения.
   В процессе работы функции используется вспомогательная матрица яркостей
пикселей, имеющая такие же размеры, как и исходная матрица яркостей пикселей
aPixelsOfImage[]. Вспомогательная матрица нужна для временного хранения новых
значений яркостей пикселей, полученных после применения оператора Собеля к
соответствующим пикселям исходной матрицы. Память для вспомогательной матрицы
выделяется и удаляется автоматически. */
void calculate_image_gradient(float aPixelsOfImage[],
                              int nImageWidth, int nImageHeight);

/* Вычислить градиент яркости растрового изображения, заданного развёрнутой по
строкам матрицей яркостей пикселей aPixelsOfImage[] шириной nImageWidth и
высотой nImageHeight. Вычисленный градиент изображения записать в
aPixelsOfImage[] вместо исходного изображения.
   В процессе работы функции используется вспомогательная матрица яркостей
пикселей, имеющая такие же размеры, как и исходная матрица яркостей пикселей
aPixelsOfImage[]. Вспомогательная матрица нужна для временного хранения новых
значений яркостей пикселей, полученных после применения оператора Собеля к
соответствующим пикселям исходной матрицы. Память для вспомогательной матрицы
должна быть выделена пользователем ещё до вызова самой функции
calculate_image_gradient. Указатель на эту память передаётся в качестве
аргумента aTmpPixelsOfImage[]. */
void calculate_image_gradient(float aPixelsOfImage[],
                              int nImageWidth, int nImageHeight,
                              float aTmpPixelsOfImage[]);

/* Выполнить сегментацию растрового изображения, заданного развёрнутой по
строкам матрицей яркостей пикселей aPixelsOfImage[] шириной nImageWidth и
высотой nImageHeight, на nClustersNumber кластеров. Вернуть результат
кластеризации в виде двухуровневого массива, первый уровень которого
соответствует кластерам, а второй уровень - пикселам каждого кластера, заданным
своими координатами. */
QVector<TClusterOfImage> segmentate_image_by_watershed_alg(
        const float aPixelsOfImage[], int nImageWidth, int nImageHeight);

#endif // IMAGE_PROCESSING_LIB_H
